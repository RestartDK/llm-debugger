<!-- f8486bf3-b6c6-4402-b1c0-27dc64402258 171392bb-b1d6-4b22-9811-ea81893b260f -->
## Implement Intermediate State Collection with Subprocess + Dummy CFG

### 1. Define a dummy CFG representation

- **Goal**: Create a minimal in-memory CFG structure that maps basic blocks to file/line ranges, without depending on the real CFG builder.
- **Actions**:
- In the MCP backend (e.g. `mcp/core/`), define a `BasicBlock` data class with fields like `block_id`, `file_path`, `start_line`, `end_line`.
- Create a small helper (or hardcoded fixture) that returns a list of `BasicBlock` instances for simple test functions spread across one or more sample Python files, so the dummy CFG already reflects a multi-file project.
- Build an `exit_line_to_block` dict mapping `(file_path, end_line)` to `block_id`.

### 2. Implement trace entry + serialization logic

- **Goal**: Have a reusable way to capture locals at a block boundary and make them JSON-safe.
- **Actions**:
- Define a `TraceEntry` data class (e.g. in a `debug_types.py` or similar) with `block_id`, `step_index`, and `locals`.
- Implement `serialize_value` and `serialize_locals` helpers that cap nesting depth and collection sizes, and skip noisy names, so locals can be safely converted to JSON.

### 3. Implement the tracer function

- **Goal**: Use `sys.settrace` to record a `TraceEntry` whenever execution hits a basic block end line.
- **Actions**:
- Implement `make_trace_fn(exit_line_to_block)` that returns a `tracer(frame, event, arg)` closure which:
- Filters to `event == "line"` and the target file.
- Looks up `(filename, lineno)` in `exit_line_to_block` to find `block_id`.
- Appends a new `TraceEntry` with serialized `frame.f_locals` and a monotonically increasing `step_index` to an internal list.
- Add a `MAX_STEPS` guard in the tracer to stop tracing once a configurable step limit is reached.

### 4. Create a standalone runner script (child process)

- **Goal**: Run arbitrary code + tests under the tracer in a separate process, using the dummy CFG.
- **Actions**:
- Add a `runner.py` in the MCP project (e.g. under `mcp/core/` or `mcp/`) that:
- Reads a JSON payload from stdin containing: `code` (source), `test_code` (asserts or function calls), and a simple CFG description (or uses an internal dummy CFG for now).
- Builds `exit_line_to_block` from the CFG description.
- Constructs the tracer with `sys.settrace(tracer)`.
- Executes `code` and then `test_code` in a shared namespace via `exec`.
- Clears tracing (`sys.settrace(None)` in a `finally` block) and prints the collected `TraceEntry` objects as JSON to stdout.

### 5. Implement a parent-side helper that uses subprocess

- **Goal**: Provide a clean Python function that the MCP routes (or local tests) can call to get a trace from code.
- **Actions**:
- In a backend module (e.g. `mcp/core/mcp_tools.py`), implement `run_with_block_tracing_subprocess(code: str, test_code: str) -> List[TraceEntry]` that:
- Builds a JSON payload with the source, tests, and dummy CFG.
- Calls `subprocess.run(["python", "runner.py"], input=payload_json, capture_output=True, text=True, timeout=5.0)`.
- Parses stdout into a list of `TraceEntry` dicts (or objects) and handles timeout / non-zero exit codes gracefully (returning a structured error instead of crashing).

### 6. Add a minimal demo / test harness

- **Goal**: Verify the whole flow locally before integrating with the full MCP routes and frontend.
- **Actions**:
- Create a tiny sample function and tests (e.g. a function with an `if` and a loop) as hardcoded strings in a test script.
- Call `run_with_block_tracing_subprocess` with this sample and print the resulting trace to the console.
- Check that the returned trace includes the expected `block_id`s and locals for each step, and that the step limit and timeout guards work as intended.

### To-dos

- [ ] Define a BasicBlock structure and a dummy CFG fixture that maps simple test code to basic blocks and builds exit_line_to_block.
- [ ] Implement TraceEntry, locals serialization helpers, and make_trace_fn(exit_line_to_block) with a MAX_STEPS guard.
- [ ] Create the runner.py subprocess script and a parent-side helper that calls it with sample code and tests, then validate the collected trace with a small demo.