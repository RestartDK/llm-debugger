{
    "nodes": [
        {
            "id": "logging_config",
            "code_chunk": "import os\nimport logging\nfrom typing import Union, Optional\nimport requests\nfrom fastapi import FastAPI, Depends, HTTPException, status, Request\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"Polymarket Telegram Bot API\", version=\"0.1.0\")",
            "explanation": "Added logging configuration, Optional import, and Pydantic BaseModel import; enhanced FastAPI app initialization with metadata.",
            "relationships": "Logging is used across all endpoints; Pydantic BaseModel is used for request/response models; Optional type is used in function return types.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "pydantic_models",
            "code_chunk": "class MessageRequest(BaseModel):\n    chat_id: int\n    text: str\n\nclass WebhookResponse(BaseModel):\n    ok: bool\n    message: Optional[str] = None\n\n# Dependency to enforce Bearer token auth\ndef verify_bearer_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    'Verify bearer token authentication'\n    if not BEARER_KEY:\n        logger.error(\"BEARER_KEY environment variable is not set\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Server configuration error.\"\n        )\n    if credentials.scheme.lower() != \"bearer\":\n        logger.warning(f\"Invalid authentication scheme: {credentials.scheme}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication scheme.\"\n        )\n    token = credentials.credentials\n    if token != BEARER_KEY:\n        logger.warning(\"Invalid bearer token attempted\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing token.\"\n        )\n    logger.info(\"Bearer token verified successfully\")\n    return token",
            "explanation": "Introduced Pydantic request/response models and enhanced token verification with logging and better error handling.",
            "relationships": "MessageRequest used by send_message_endpoint; WebhookResponse used by telegram_webhook; verify_bearer_token used by health, webhook, and send_message endpoints; logger from logging_config.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "health_endpoint",
            "code_chunk": "@app.get(\"/health\")\ndef health():\n    'Health check endpoint'\n    bot_configured = bool(os.getenv(\"TELEGRAM_BOT_KEY\"))\n    return {\n        \"status\": \"healthy\",\n        \"bot_configured\": bot_configured,\n        \"message\": \"Service is running\"\n    }",
            "explanation": "Extended health check to include bot configuration status and added a docstring.",
            "relationships": "Uses os.getenv from logging_config; provides health status for monitoring.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "register_webhook",
            "code_chunk": "@app.post(\"/register_webhook\")\ndef register_webhook(token: str = Depends(verify_bearer_token)):\n    'Register Telegram webhook URL'\n    BOT_KEY = os.getenv(\"TELEGRAM_BOT_KEY\")\n    WEBHOOK_URL = os.getenv(\"WEBHOOK_URL\")\n    \n    if not BOT_KEY:\n        logger.error(\"TELEGRAM_BOT_KEY not configured\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bot key not configured\"\n        )\n    if not WEBHOOK_URL:\n        logger.error(\"WEBHOOK_URL not configured\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Webhook URL not configured\"\n        )\n    \n    registration_url = f\"https://api.telegram.org/bot{BOT_KEY}/setWebhook\"\n    \n    try:\n        response = requests.post(registration_url, data={\"url\": WEBHOOK_URL}, timeout=10)\n        response.raise_for_status()\n        logger.info(f\"Webhook registered successfully: {WEBHOOK_URL}\")\n        return {\n            \"message\": \"Webhook registered successfully\",\n            \"webhook_url\": WEBHOOK_URL,\n            \"status_code\": response.status_code\n        }\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to register webhook: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_502_BAD_GATEWAY,\n            detail=f\"Failed to register webhook: {str(e)}\"\n        )",
            "explanation": "Added validation, logging, timeout, and exception handling to webhook registration; renamed function for clarity.",
            "relationships": "Uses verify_bearer_token from pydantic_models; uses logger from logging_config; uses requests library.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "webhook_and_send_message",
            "code_chunk": "@app.post(\"/webhook\", response_model=WebhookResponse)\nasync def telegram_webhook(request: Request):\n    'Handle incoming Telegram webhook updates'\n    try:\n        update = await request.json()\n        logger.info(f\"Received webhook update: {update.get('update_id', 'unknown')}\")\n        \n        message = update.get('message', {})\n        chat_id = message.get('chat', {}).get('id')\n        text = message.get('text', '')\n\n        if not chat_id:\n            logger.warning(\"Received update without chat_id\")\n            return WebhookResponse(ok=True, message=\"Update processed but no chat_id found\")\n\n        if text == '/start':\n            send_message(chat_id, \"Send your invite link\")\n            logger.info(f\"Sent start message to chat {chat_id}\")\n        elif text:\n            send_message(chat_id, f\"You sent: {text}\")\n            logger.info(f\"Echoed message to chat {chat_id}\")\n        \n        return WebhookResponse(ok=True, message=\"Update processed successfully\")\n    except Exception as e:\n        logger.error(f\"Error processing webhook: {str(e)}\")\n        return WebhookResponse(ok=False, message=f\"Error: {str(e)}\")\n\n@app.post(\"/send_message\")\ndef send_message_endpoint(message_req: MessageRequest, token: str = Depends(verify_bearer_token)):\n    'API endpoint to send a message to a Telegram chat'\n    result = send_message(message_req.chat_id, message_req.text)\n    if result is None:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Failed to send message. Check BOT_TOKEN and chat_id.\"\n        )\n    return {\n        \"success\": True,\n        \"message\": \"Message sent successfully\",\n        \"chat_id\": message_req.chat_id\n    }",
            "explanation": "Improved webhook handling with logging and response model; added authenticated send_message endpoint.",
            "relationships": "Uses WebhookResponse and MessageRequest models from pydantic_models; uses verify_bearer_token; calls send_message function; uses logger from logging_config.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "send_message_function",
            "code_chunk": "def send_message(chat_id: int, text: str) -> Optional[dict]:\n    '\n    Send a message to a Telegram chat.\n    \n    Args:\n        chat_id: Telegram chat ID\n        text: Message text to send\n        \n    Returns:\n        Response dict if successful, None otherwise\n    \n    BOT_TOKEN = os.getenv('TELEGRAM_BOT_KEY')\n    if not BOT_TOKEN:\n        logger.error(\"TELEGRAM_BOT_KEY not configured\")\n        return None\n    if not chat_id:\n        logger.error(\"chat_id is required\")\n        return None\n    \n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\n        \"chat_id\": chat_id,\n        \"text\": text\n    }\n    try:\n        response = requests.post(url, json=payload, timeout=10)\n        response.raise_for_status()\n        logger.info(f\"Message sent successfully to chat {chat_id}\")\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to send message to chat {chat_id}: {str(e)}\")\n        return None",
            "explanation": "Added type hints, docstring, logging, timeout, and proper exception handling; returns response JSON.",
            "relationships": "Called by webhook_and_send_message; uses logger from logging_config; returns Optional using Optional type from logging_config.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "project_metadata",
            "code_chunk": "[project]\nname = \"polymarket-telegram-bot\"\nversion = \"0.1.0\"\ndescription = \"API to receive webhooks from Telegram and trigger messages to be sent once received from a user\"\nreadme = \"README.md\"\nrequires-python = \">=3.12\"\ndependencies = [\n    \"fastapi[standard]>=0.116.1\",\n    \"requests>=2.32.5\",\n    \"uvicorn>=0.22.0\",\n    \"pydantic>=2.0.0\",\n]",
            "explanation": "Updated project name, description, and added pydantic dependency for the new models.",
            "relationships": "Pydantic dependency supports models in pydantic_models; project metadata aligns with README.",
            "filename": "pyproject.toml",
            "line_range": ""
        },
        {
            "id": "nixpacks_start",
            "code_chunk": "[start]\ncmd = \"fastapi run main.py --port 3000\"",
            "explanation": "Switched start command to FastAPI CLI and changed port to 3000.",
            "relationships": "Port matches running instructions in README; uses fastapi CLI from fastapi[standard] dependency.",
            "filename": "nixpacks.toml",
            "line_range": ""
        },
        {
            "id": "readme_update",
            "code_chunk": "# Polymarket Telegram Bot API\n\nAPI to receive webhooks from Telegram and trigger messages to be sent once received from a user.\n\n## Features\n\n- Telegram webhook handling\n- Bearer token authentication\n- Message sending functionality\n- Health check endpoint\n\n## Environment Variables\n\n- `BEARER_KEY`: Bearer token for API authentication\n- `TELEGRAM_BOT_KEY`: Telegram bot token\n- `WEBHOOK_URL`: URL for Telegram webhook registration\n\n## Endpoints\n\n- `GET /health` - Health check endpoint\n- `POST /register_webhook` - Register Telegram webhook (requires auth)\n- `POST /webhook` - Handle incoming Telegram updates\n- `POST /send_message` - Send a message to a Telegram chat (requires auth)\n\n## Running Locally\n\n```bash\nfastapi run main.py --port 3000\n```",
            "explanation": "Rewrote README with markdown sections for features, env vars, endpoints, and run instructions.",
            "relationships": "Documents endpoints from health_endpoint, register_webhook, webhook_and_send_message; documents env vars used in main.py; run instructions match nixpacks_start.",
            "filename": "README.md",
            "line_range": ""
        }
    ]
}