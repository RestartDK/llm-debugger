{
    "nodes": [
        {
            "id": "logging_setup",
            "code_chunk": "import os\nimport logging\nfrom typing import Union, Optional\nimport requests\nfrom fastapi import FastAPI, Depends, HTTPException, status, Request\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"Polymarket Telegram Bot API\", version=\"0.1.0\")",
            "explanation": "Added logging configuration, Optional import, and Pydantic BaseModel import; initialized FastAPI with title and version.",
            "relationships": "Logging is used across all endpoints; BaseModel is used for request/response models; Optional type is used in function return types.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "pydantic_models_auth",
            "code_chunk": "# Pydantic models for request/response validation\nclass MessageRequest(BaseModel):\n    chat_id: int\n    text: str\n\nclass WebhookResponse(BaseModel):\n    ok: bool\n    message: Optional[str] = None\n\n# Dependency to enforce Bearer token auth\ndef verify_bearer_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    'Verify bearer token authentication'\n    if not BEARER_KEY:\n        logger.error(\"BEARER_KEY environment variable is not set\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Server configuration error.\"\n        )\n    if credentials.scheme.lower() != \"bearer\":\n        logger.warning(f\"Invalid authentication scheme: {credentials.scheme}\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication scheme.\"\n        )\n    token = credentials.credentials\n    if token != BEARER_KEY:\n        logger.warning(\"Invalid bearer token attempted\")\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing token.\"\n        )\n    logger.info(\"Bearer token verified successfully\")\n    return token",
            "explanation": "Introduced MessageRequest and WebhookResponse Pydantic models and enhanced token verification with logging and better error handling.",
            "relationships": "Models used by webhook and send_message endpoints; verify_bearer_token used by multiple endpoints; relies on logger from logging_setup.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "health_endpoint",
            "code_chunk": "@app.get(\"/health\")\ndef health():\n    'Health check endpoint'\n    bot_configured = bool(os.getenv(\"TELEGRAM_BOT_KEY\"))\n    return {\n        \"status\": \"healthy\",\n        \"bot_configured\": bot_configured,\n        \"message\": \"Service is running\"\n    }",
            "explanation": "Extended health check to include bot configuration status and added a docstring.",
            "relationships": "Uses os.getenv imported in logging_setup; provides status for monitoring systems.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "register_webhook_endpoint",
            "code_chunk": "@app.post(\"/register_webhook\")\ndef register_webhook(token: str = Depends(verify_bearer_token)):\n    'Register Telegram webhook URL'\n    BOT_KEY = os.getenv(\"TELEGRAM_BOT_KEY\")\n    WEBHOOK_URL = os.getenv(\"WEBHOOK_URL\")\n    \n    if not BOT_KEY:\n        logger.error(\"TELEGRAM_BOT_KEY not configured\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Bot key not configured\"\n        )\n    if not WEBHOOK_URL:\n        logger.error(\"WEBHOOK_URL not configured\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Webhook URL not configured\"\n        )\n    \n    registration_url = f\"https://api.telegram.org/bot{BOT_KEY}/setWebhook\"\n    \n    try:\n        response = requests.post(registration_url, data={\"url\": WEBHOOK_URL}, timeout=10)\n        response.raise_for_status()\n        logger.info(f\"Webhook registered successfully: {WEBHOOK_URL}\")\n        return {\n            \"message\": \"Webhook registered successfully\",\n            \"webhook_url\": WEBHOOK_URL,\n            \"status_code\": response.status_code\n        }\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to register webhook: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_502_BAD_GATEWAY,\n            detail=f\"Failed to register webhook: {str(e)}\"\n        )",
            "explanation": "Added validation of environment variables, error handling, timeout, logging, and richer response for webhook registration.",
            "relationships": "Depends on verify_bearer_token from pydantic_models_auth; uses logger from logging_setup; makes HTTP call with requests.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "webhook_and_send_message",
            "code_chunk": "@app.post(\"/webhook\", response_model=WebhookResponse)\nasync def telegram_webhook(request: Request):\n    'Handle incoming Telegram webhook updates'\n    try:\n        update = await request.json()\n        logger.info(f\"Received webhook update: {update.get('update_id', 'unknown')}\")\n        \n        message = update.get('message', {})\n        chat_id = message.get('chat', {}).get('id')\n        text = message.get('text', '')\n\n        if not chat_id:\n            logger.warning(\"Received update without chat_id\")\n            return WebhookResponse(ok=True, message=\"Update processed but no chat_id found\")\n\n        if text == '/start':\n            send_message(chat_id, \"Send your invite link\")\n            logger.info(f\"Sent start message to chat {chat_id}\")\n        elif text:\n            # Here, you can validate/check the invite link, reply, etc.\n            send_message(chat_id, f\"You sent: {text}\")\n            logger.info(f\"Echoed message to chat {chat_id}\")\n        \n        return WebhookResponse(ok=True, message=\"Update processed successfully\")\n    except Exception as e:\n        logger.error(f\"Error processing webhook: {str(e)}\")\n        return WebhookResponse(ok=False, message=f\"Error: {str(e)}\")\n\n@app.post(\"/send_message\")\ndef send_message_endpoint(message_req: MessageRequest, token: str = Depends(verify_bearer_token)):\n    'API endpoint to send a message to a Telegram chat'\n    result = send_message(message_req.chat_id, message_req.text)\n    if result is None:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Failed to send message. Check BOT_TOKEN and chat_id.\"\n        )\n    return {\n        \"success\": True,\n        \"message\": \"Message sent successfully\",\n        \"chat_id\": message_req.chat_id\n    }",
            "explanation": "Enhanced webhook handling with logging, error handling, and response model; added authenticated send_message endpoint.",
            "relationships": "Uses WebhookResponse and MessageRequest models from pydantic_models_auth; relies on verify_bearer_token; calls send_message function; logs via logger.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "send_message_function",
            "code_chunk": "def send_message(chat_id: int, text: str) -> Optional[dict]:\n    '\n    Send a message to a Telegram chat.\n    \n    Args:\n        chat_id: Telegram chat ID\n        text: Message text to send\n        \n    Returns:\n        Response dict if successful, None otherwise\n    \n    BOT_TOKEN = os.getenv('TELEGRAM_BOT_KEY')\n    if not BOT_TOKEN:\n        logger.error(\"TELEGRAM_BOT_KEY not configured\")\n        return None\n    if not chat_id:\n        logger.error(\"chat_id is required\")\n        return None\n    \n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    payload = {\n        \"chat_id\": chat_id,\n        \"text\": text\n    }\n    try:\n        response = requests.post(url, json=payload, timeout=10)\n        response.raise_for_status()\n        logger.info(f\"Message sent successfully to chat {chat_id}\")\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to send message to chat {chat_id}: {str(e)}\")\n        return None",
            "explanation": "Added type hints, comprehensive docstring, validation, timeout, exception handling, and logging; returns response JSON.",
            "relationships": "Called by webhook_and_send_message endpoints; uses logger from logging_setup; returns Optional[dict] using Optional type.",
            "filename": "main.py",
            "line_range": ""
        },
        {
            "id": "project_metadata",
            "code_chunk": "[project]\nname = \"polymarket-telegram-bot\"\nversion = \"0.1.0\"\ndescription = \"API to receive webhooks from Telegram and trigger messages to be sent once received from a user\"\nreadme = \"README.md\"\nrequires-python = \">=3.12\"\ndependencies = [\n    \"fastapi[standard]>=0.116.1\",\n    \"requests>=2.32.5\",\n    \"uvicorn>=0.22.0\",\n    \"pydantic>=2.0.0\",\n]",
            "explanation": "Renamed project, improved description, and added pydantic dependency for models.",
            "relationships": "Pydantic dependency supports models defined in pydantic_models_auth; aligns with README documentation.",
            "filename": "pyproject.toml",
            "line_range": ""
        },
        {
            "id": "nixpacks_start",
            "code_chunk": "[start]\ncmd = \"fastapi run main.py --port 3000\"",
            "explanation": "Switched start command to FastAPI CLI and updated port to 3000.",
            "relationships": "Port matches running instructions in README; uses fastapi CLI from fastapi[standard] dependency.",
            "filename": "nixpacks.toml",
            "line_range": ""
        },
        {
            "id": "readme_content",
            "code_chunk": "# Polymarket Telegram Bot API\n\nAPI to receive webhooks from Telegram and trigger messages to be sent once received from a user.\n\n## Features\n\n- Telegram webhook handling\n- Bearer token authentication\n- Message sending functionality\n- Health check endpoint\n\n## Environment Variables\n\n- `BEARER_KEY`: Bearer token for API authentication\n- `TELEGRAM_BOT_KEY`: Telegram bot token\n- `WEBHOOK_URL`: URL for Telegram webhook registration\n\n## Endpoints\n\n- `GET /health` - Health check endpoint\n- `POST /register_webhook` - Register Telegram webhook (requires auth)\n- `POST /webhook` - Handle incoming Telegram updates\n- `POST /send_message` - Send a message to a Telegram chat (requires auth)\n\n## Running Locally\n\n```bash\nfastapi run main.py --port 3000\n```",
            "explanation": "Rewrote README with markdown, detailing features, env vars, endpoints, and run instructions.",
            "relationships": "Documents endpoints from health_endpoint, register_webhook_endpoint, webhook_and_send_message; aligns with nixpacks_start configuration.",
            "filename": "README.md",
            "line_range": ""
        }
    ],
    "edges": [
        {
            "id": "2c51eed5-40c2-466d-8506-4d9851fde781",
            "from_node": "logging_setup",
            "to_node": "health_endpoint",
            "relationship_type": "uses"
        },
        {
            "id": "397f243a-eac9-4133-9f12-f863771fdfce",
            "from_node": "logging_setup",
            "to_node": "register_webhook_endpoint",
            "relationship_type": "uses"
        },
        {
            "id": "bb29c9f6-e283-4424-a4d0-371e751b59c0",
            "from_node": "logging_setup",
            "to_node": "webhook_and_send_message",
            "relationship_type": "uses"
        },
        {
            "id": "77426cdd-115f-4230-9af6-7c93afafd5d3",
            "from_node": "logging_setup",
            "to_node": "send_message_function",
            "relationship_type": "uses"
        },
        {
            "id": "d3bdab61-81c1-4d15-bdce-bc89478fa476",
            "from_node": "logging_setup",
            "to_node": "pydantic_models_auth",
            "relationship_type": "uses"
        },
        {
            "id": "6a9b30e4-f478-48a4-931b-fe622755dac3",
            "from_node": "logging_setup",
            "to_node": "project_metadata",
            "relationship_type": "uses"
        },
        {
            "id": "31b98e50-5aa5-44ef-9864-6d7a8e23b296",
            "from_node": "pydantic_models_auth",
            "to_node": "logging_setup",
            "relationship_type": "depends_on"
        },
        {
            "id": "8e02d548-f41a-48e2-a431-b1a21a41a1d5",
            "from_node": "pydantic_models_auth",
            "to_node": "webhook_and_send_message",
            "relationship_type": "uses"
        },
        {
            "id": "4015fc91-666c-4f4c-a6b4-b43a10a8c8aa",
            "from_node": "pydantic_models_auth",
            "to_node": "send_message_function",
            "relationship_type": "uses"
        },
        {
            "id": "0ca4effa-9b6d-441a-8f01-992797f9015b",
            "from_node": "pydantic_models_auth",
            "to_node": "register_webhook_endpoint",
            "relationship_type": "uses"
        },
        {
            "id": "f73d3eff-57a5-452d-957b-504fca756f75",
            "from_node": "register_webhook_endpoint",
            "to_node": "pydantic_models_auth",
            "relationship_type": "depends_on"
        },
        {
            "id": "4da57947-d15d-47aa-8648-2b44e6684312",
            "from_node": "register_webhook_endpoint",
            "to_node": "logging_setup",
            "relationship_type": "uses"
        },
        {
            "id": "ca1ef09a-e6d4-4256-a9da-de07d09b1eaf",
            "from_node": "webhook_and_send_message",
            "to_node": "pydantic_models_auth",
            "relationship_type": "uses"
        },
        {
            "id": "8550ca88-d411-4bb9-aea0-02adb694a24b",
            "from_node": "webhook_and_send_message",
            "to_node": "send_message_function",
            "relationship_type": "calls"
        },
        {
            "id": "28425e32-a881-48fb-806e-cf571fe86dd5",
            "from_node": "webhook_and_send_message",
            "to_node": "logging_setup",
            "relationship_type": "uses"
        },
        {
            "id": "29b57a3b-af62-4748-8b16-ee8e91421dde",
            "from_node": "send_message_function",
            "to_node": "logging_setup",
            "relationship_type": "uses"
        },
        {
            "id": "aca464d7-ca9a-48ed-a472-67945ddb6780",
            "from_node": "project_metadata",
            "to_node": "pydantic_models_auth",
            "relationship_type": "depends_on"
        },
        {
            "id": "7c1321d7-7ae1-43f7-bc9a-2e629bcedc18",
            "from_node": "project_metadata",
            "to_node": "readme_content",
            "relationship_type": "references"
        },
        {
            "id": "97d8d518-e078-4b03-b4d9-8626a7c66915",
            "from_node": "nixpacks_start",
            "to_node": "readme_content",
            "relationship_type": "depends_on"
        },
        {
            "id": "ee3f4db2-dce7-4a70-95c0-4bd357814e27",
            "from_node": "readme_content",
            "to_node": "health_endpoint",
            "relationship_type": "references"
        },
        {
            "id": "516499a0-d337-43b9-9b2d-aaa2d4ca24e7",
            "from_node": "readme_content",
            "to_node": "register_webhook_endpoint",
            "relationship_type": "references"
        },
        {
            "id": "a9feb704-7a93-493a-b7c2-c867028d563f",
            "from_node": "readme_content",
            "to_node": "webhook_and_send_message",
            "relationship_type": "references"
        },
        {
            "id": "14d4f7ee-9eb5-40f2-851f-e76459846c85",
            "from_node": "readme_content",
            "to_node": "nixpacks_start",
            "relationship_type": "references"
        }
    ]
}